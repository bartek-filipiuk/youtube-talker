name: Deploy to Production

on:
  push:
    branches:
      - main

jobs:
  deploy:
    name: Deploy to Digital Ocean
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" | tr -d '\r' > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          chmod 700 ~/.ssh
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      - name: Validate SSH key
        run: |
          echo "üîç Validating SSH key format..."
          if [ ! -s ~/.ssh/deploy_key ]; then
            echo "‚ùå ERROR: SSH key file is empty or doesn't exist"
            exit 1
          fi

          # Check if key starts with proper header
          if ! head -n 1 ~/.ssh/deploy_key | grep -q "BEGIN.*PRIVATE KEY"; then
            echo "‚ùå ERROR: SSH key doesn't have proper header"
            echo "First line should be: -----BEGIN OPENSSH PRIVATE KEY----- or similar"
            echo "Actual first line: $(head -n 1 ~/.ssh/deploy_key)"
            exit 1
          fi

          echo "‚úÖ SSH key format looks valid"

          # Test SSH connection
          echo "üîå Testing SSH connection..."
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o ConnectTimeout=10 ${SERVER_USER}@${SERVER_HOST} "echo '‚úÖ SSH connection successful'" || {
            echo "‚ùå SSH connection failed"
            echo "Please check:"
            echo "  1. SSH_PRIVATE_KEY secret contains the full private key"
            echo "  2. Key includes -----BEGIN and -----END lines"
            echo "  3. Public key is added to server's ~/.ssh/authorized_keys"
            echo "  4. SERVER_USER has correct permissions on server"
            exit 1
          }
        env:
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}

      - name: Deploy to server
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_DEPLOY_PATH: ${{ secrets.SERVER_DEPLOY_PATH }}
        run: |
          ssh -i ~/.ssh/deploy_key ${SERVER_USER}@${SERVER_HOST} << 'ENDSSH'
            set -e

            echo "üöÄ Starting deployment..."

            # Navigate to deployment directory
            cd ${{ secrets.SERVER_DEPLOY_PATH }}

            # Pull latest changes
            echo "üì• Pulling latest code from main..."
            git fetch origin
            git reset --hard origin/main

            # Run deployment script
            echo "üîß Running deployment script..."
            bash scripts/deploy.sh

            echo "‚úÖ Deployment completed successfully!"
          ENDSSH

      - name: Health check
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
        run: |
          echo "üè• Running health check..."
          sleep 10

          # Check backend health
          response=$(curl -s -o /dev/null -w "%{http_code}" https://api.qivio.pl/api/health || echo "000")
          if [ "$response" -eq 200 ]; then
            echo "‚úÖ Backend is healthy (HTTP $response)"
          else
            echo "‚ùå Backend health check failed (HTTP $response)"
            exit 1
          fi

          # Check frontend
          response=$(curl -s -o /dev/null -w "%{http_code}" https://qivio.pl || echo "000")
          if [ "$response" -eq 200 ]; then
            echo "‚úÖ Frontend is healthy (HTTP $response)"
          else
            echo "‚ö†Ô∏è  Frontend health check returned HTTP $response"
          fi

      - name: Cleanup SSH keys
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ Deployment to production was successful!"
          else
            echo "‚ùå Deployment to production failed!"
          fi
