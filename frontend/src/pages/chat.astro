---
import Layout from '../layouts/Layout.astro';
import ChatInput from '../components/ChatInput.astro';
import ConversationList from '../components/ConversationList.astro';

// Get conversation ID from URL (for highlighting active conversation)
const urlParams = new URLSearchParams(Astro.url.search);
const activeConversationId = urlParams.get('id');
---

<Layout title="Chat">
  <div class="flex h-screen bg-gray-50">
    <!-- Conversation Sidebar - Hidden on mobile, visible on tablet+ -->
    <aside class="hidden md:block w-80 flex-shrink-0">
      <ConversationList activeId={activeConversationId} />
    </aside>

    <!-- Main Chat Area - Full width on mobile, flexible on tablet+ -->
    <main class="flex-1 flex flex-col w-full md:w-auto">
      <!-- Header -->
      <header class="bg-white border-b border-gray-200 px-6 py-4 flex justify-between items-center">
        <div>
          <h1 class="text-2xl font-bold text-gray-900">YoutubeTalker</h1>
          <p class="text-sm text-gray-600">Chat with your YouTube videos</p>
        </div>
        <a
          href="/logout"
          class="px-4 py-2 text-sm text-gray-700 hover:text-gray-900 hover:bg-gray-100 rounded-lg transition"
        >
          Logout
        </a>
      </header>

      <!-- Messages Container -->
      <div id="messagesContainer" class="flex-1 overflow-y-auto px-4 py-3 space-y-4">
      <!-- Error Message (populated client-side if needed) -->
      <div id="errorMessage" class="hidden bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4" role="alert">
        <p class="font-bold">Error loading conversation</p>
        <p id="errorText"></p>
      </div>

      <!-- Messages will be rendered here -->
      <div id="messagesList" class="space-y-4"></div>

      <!-- Typing Indicator -->
      <div id="typingIndicator" class="hidden flex items-center gap-2 text-gray-500">
        <div class="flex gap-1">
          <span class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0ms"></span>
          <span class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 150ms"></span>
          <span class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 300ms"></span>
        </div>
        <span class="text-sm">AI is typing...</span>
      </div>
    </div>

    <!-- Input Area -->
    <ChatInput />

      <!-- Connection Status -->
      <div id="connectionStatus" class="hidden fixed bottom-24 right-6 px-4 py-2 bg-yellow-100 border border-yellow-300 rounded-lg text-sm text-yellow-800">
        Reconnecting...
      </div>
    </main>
  </div>
</Layout>

<script>
  import { requireAuth } from '../lib/auth';
  import { WebSocketClient } from '../lib/websocket';
  import { getConversation, createConversation } from '../lib/api';
  import { $messages, $isTyping, addMessage, startStreaming, appendToStream, finalizeStreaming, setMessages } from '../stores/chat';
  import { renderMarkdown } from '../lib/markdown';

  // Ensure user is authenticated
  const auth = await requireAuth();
  if (!auth) {
    // Will redirect to login
    throw new Error('Not authenticated');
  }

  const { token } = auth;

  // DOM elements
  const messagesContainer = document.getElementById('messagesContainer') as HTMLDivElement;
  const messagesList = document.getElementById('messagesList') as HTMLDivElement;
  const errorMessage = document.getElementById('errorMessage') as HTMLDivElement;
  const errorText = document.getElementById('errorText') as HTMLParagraphElement;

  // Function to show error
  function showError(message: string) {
    errorText.textContent = message;
    errorMessage.classList.remove('hidden');
  }

  // Get or create conversation ID
  let conversationId: string | null = null;
  const urlParams = new URLSearchParams(window.location.search);
  conversationId = urlParams.get('id');

  // If no conversation ID, create one and redirect
  if (!conversationId) {
    try {
      const newConversation = await createConversation(token);
      conversationId = newConversation.id;
      window.location.href = `/chat?id=${conversationId}`;
      // Stop execution here - page will reload with conversation ID
      throw new Error('Redirecting...');
    } catch (error: any) {
      showError('Failed to create conversation: ' + error.message);
      throw error;
    }
  }

  // Load conversation messages
  try {
    const conversation = await getConversation(token, conversationId);
    const initialMessages = conversation.messages || [];

    if (initialMessages.length > 0) {
      const formattedMessages = initialMessages.map((msg: any) => ({
        role: msg.role,
        content: msg.content,
        timestamp: new Date(msg.created_at),
        isStreaming: false
      }));
      setMessages(formattedMessages);
    }
  } catch (error: any) {
    console.error('Error loading conversation:', error);
    showError('Failed to load conversation: ' + error.message);
  }

  // WebSocket configuration (conversation ID is sent in message payload, not URL)
  const WS_URL = import.meta.env.PUBLIC_WS_URL || 'ws://localhost:8000/api/ws/chat';

  // Initialize WebSocket
  const wsClient = new WebSocketClient(WS_URL, token);
  const typingIndicator = document.getElementById('typingIndicator') as HTMLDivElement;
  const connectionStatus = document.getElementById('connectionStatus') as HTMLDivElement;
  const chatForm = document.getElementById('chatForm') as HTMLFormElement;
  const chatInput = (window as any).chatInput;

  // Subscribe to message store changes
  $messages.subscribe((messages) => {
    renderMessages(messages);
  });

  // Subscribe to typing indicator
  $isTyping.subscribe((isTyping) => {
    if (isTyping) {
      typingIndicator.classList.remove('hidden');
    } else {
      typingIndicator.classList.add('hidden');
    }
    scrollToBottom();
  });

  // Render messages
  function renderMessages(messages: any[]) {
    messagesList.innerHTML = messages
      .map((msg) => {
        const isUser = msg.role === 'user';
        const timestamp = new Date(msg.timestamp).toLocaleTimeString('en-US', {
          hour: '2-digit',
          minute: '2-digit'
        });

        return `
          <div class="flex ${isUser ? 'justify-end' : 'justify-start'} mb-4 animate-fade-in">
            <div class="max-w-3xl px-3 py-2 rounded-lg shadow-sm ${
              isUser
                ? 'bg-gray-50 text-gray-900 border border-gray-200'
                : 'bg-white text-gray-900 border border-gray-200'
            }">
              <div class="break-words ${
                isUser
                  ? 'whitespace-pre-line'
                  : 'prose'
              }">
                ${isUser ? escapeHtml(msg.content) : sanitizeHtml(msg.content)}
                ${msg.isStreaming ? '<span class="inline-block w-2 h-4 bg-gray-400 animate-pulse ml-1"></span>' : ''}
              </div>
              <div class="text-xs mt-2 text-gray-500">
                ${timestamp}
              </div>
            </div>
          </div>
        `;
      })
      .join('');

    scrollToBottom();
  }

  // Escape HTML to prevent XSS in user messages
  function escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // Render markdown for assistant messages
  function sanitizeHtml(content: string): string {
    // Use renderMarkdown utility for safe markdown rendering
    return renderMarkdown(content);
  }

  // Scroll to bottom of messages
  function scrollToBottom() {
    setTimeout(() => {
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }, 0);
  }

  // Handle WebSocket messages
  wsClient.onMessage((data) => {
    console.log('WebSocket message:', data);

    if (data.type === 'status') {
      // Show status message in typing indicator (without creating a message)
      // Skip "Connected as..." messages - those are just connection confirmations
      if (data.message && !data.message.startsWith('Connected as')) {
        // Show typing indicator with custom status text
        typingIndicator.classList.remove('hidden');
        const statusText = typingIndicator.querySelector('span.text-sm');
        if (statusText) {
          statusText.textContent = data.message;
        }
        scrollToBottom();
      }
    } else if (data.type === 'message') {
      if (data.content) {
        // Hide typing indicator
        typingIndicator.classList.add('hidden');

        // Backend sends complete message at once (not streamed)
        // Start streaming, add content, and finalize immediately
        startStreaming();
        appendToStream(data.content);
        finalizeStreaming();
        chatInput.enable(); // Re-enable input after response completes
      }
    } else if (data.type === 'video_load_confirmation') {
      // Video loading confirmation request from backend
      typingIndicator.classList.add('hidden');

      // Display confirmation message from assistant (using simple text)
      let confirmationText = data.message;
      if (data.video_title) {
        confirmationText += `\n\n**Video:** ${data.video_title}`;
      }
      confirmationText += '\n\nReply with "yes" or "no"';

      startStreaming();
      appendToStream(confirmationText);
      finalizeStreaming();
      chatInput.enable(); // Re-enable input to allow yes/no response
    } else if (data.type === 'video_load_status') {
      // Video loading status update
      typingIndicator.classList.add('hidden');

      let statusContent = '';
      if (data.status === 'started') {
        // Show status in typing indicator instead of message
        const statusText = typingIndicator.querySelector('span.text-sm');
        if (statusText) {
          statusText.textContent = data.message || 'Loading video...';
        }
        typingIndicator.classList.remove('hidden');
        scrollToBottom();
        return; // Don't create a message for 'started' status
      } else if (data.status === 'completed') {
        statusContent = `✓ **Success:** ${data.message}`;
        if (data.video_title) {
          statusContent += `\n\n**Video:** ${data.video_title}`;
        }
        chatInput.enable(); // Re-enable input after completion
      } else if (data.status === 'failed') {
        statusContent = `✗ **Failed:** ${data.message}`;
        if (data.error) {
          statusContent += `\n\nError: ${data.error}`;
        }
        chatInput.enable(); // Re-enable input after failure
      }

      if (statusContent) {
        startStreaming();
        appendToStream(statusContent);
        finalizeStreaming();
      }
    } else if (data.type === 'error') {
      // Hide typing indicator on error
      typingIndicator.classList.add('hidden');
      alert('Error: ' + (data.message || 'Unknown error'));
      finalizeStreaming();
      chatInput.enable();
    }
  });

  // Handle WebSocket errors
  wsClient.onError((error) => {
    console.error('WebSocket error:', error);
    connectionStatus.classList.remove('hidden');
  });

  // Connect WebSocket
  wsClient.connect();

  // Handle form submission
  chatForm.addEventListener('submit', async (e) => {
    e.preventDefault();

    const message = chatInput.getValue();
    if (!message) return;

    // Add user message to chat
    addMessage('user', message);

    // Clear input
    chatInput.clear();
    chatInput.disable();

    // Send message via WebSocket
    wsClient.sendMessage(message, conversationId);
  });

  // Cleanup on page unload
  window.addEventListener('beforeunload', () => {
    wsClient.disconnect();
  });

  // Focus input on load
  chatInput.focus();
</script>

<style>
  @keyframes fade-in {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .animate-fade-in {
    animation: fade-in 0.3s ease-out;
  }
</style>
