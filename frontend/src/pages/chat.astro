---
import Layout from '../layouts/Layout.astro';
import ChatInput from '../components/ChatInput.astro';
import ConversationList from '../components/ConversationList.astro';
import VideoList from '../components/VideoList.astro';

// Get conversation ID from URL (for highlighting active conversation)
const urlParams = new URLSearchParams(Astro.url.search);
const activeConversationId = urlParams.get('id');
---

<Layout title="Chat">
  <div class="flex h-screen bg-gray-50 overflow-hidden">
    <!-- Conversation Sidebar - Hidden on mobile, visible on tablet+ -->
    <aside class="hidden md:block w-80 flex-shrink-0 flex flex-col">
      <!-- Video List at top -->
      <VideoList />

      <!-- Conversation List below (scrollable) -->
      <div class="flex-1 overflow-hidden">
        <ConversationList activeId={activeConversationId} />
      </div>
    </aside>

    <!-- Main Chat Area - Full width on mobile, flexible on tablet+ -->
    <main class="flex-1 flex flex-col w-full md:w-auto min-h-0">

      <!-- Messages Container (with bottom padding for sticky input) -->
      <div id="messagesContainer" class="flex-1 overflow-y-auto px-4 py-3 pb-44 space-y-4">
      <!-- Error Message (populated client-side if needed) -->
      <div id="errorMessage" class="hidden bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4" role="alert">
        <p class="font-bold">Error loading conversation</p>
        <p id="errorText"></p>
      </div>

      <!-- Messages will be rendered here -->
      <div id="messagesList" class="space-y-4"></div>

      <!-- Status Message Queue (replaces single typing indicator) -->
      <div id="statusQueueContainer" class="hidden space-y-2"></div>
    </div>

    <!-- Input Area -->
    <ChatInput />

      <!-- Connection Status -->
      <div id="connectionStatus" class="hidden fixed bottom-24 right-6 px-4 py-2 bg-yellow-100 border border-yellow-300 rounded-lg text-sm text-yellow-800">
        Reconnecting...
      </div>
    </main>
  </div>
</Layout>

<script>
  import { requireAuth, showToast } from '../lib/auth';
  import { WebSocketClient } from '../lib/websocket';
  import { getConversation, createConversation, getLatestConversation } from '../lib/api';
  import { $messages, $isTyping, addMessage, startStreaming, appendToStream, finalizeStreaming, setMessages } from '../stores/chat';
  import { renderMarkdown } from '../lib/markdown';
  import { StatusQueue } from '../lib/status-queue';

  // Ensure user is authenticated
  const auth = await requireAuth();
  if (!auth) {
    // Will redirect to login
    throw new Error('Not authenticated');
  }

  const { token } = auth;

  // DOM elements
  const messagesContainer = document.getElementById('messagesContainer') as HTMLDivElement;
  const messagesList = document.getElementById('messagesList') as HTMLDivElement;
  const errorMessage = document.getElementById('errorMessage') as HTMLDivElement;
  const errorText = document.getElementById('errorText') as HTMLParagraphElement;

  // Function to show error
  function showError(message: string) {
    errorText.textContent = message;
    errorMessage.classList.remove('hidden');
  }

  // Get or create conversation ID
  let conversationId: string | null = null;
  const urlParams = new URLSearchParams(window.location.search);
  conversationId = urlParams.get('id');

  // If no conversation ID in URL, try to fetch latest conversation first
  if (!conversationId) {
    try {
      // Try to get the latest conversation
      const latestConversation = await getLatestConversation(token);
      conversationId = latestConversation.id;
      window.location.href = `/chat?id=${conversationId}`;
      // Stop execution here - page will reload with conversation ID
      throw new Error('Redirecting to latest conversation...');
    } catch (error: any) {
      // If no conversations exist (404), create a new one
      // This only happens for brand new users or when using "New Chat" button
      if (error.message.includes('Conversation not found') || error.message.includes('Failed to load latest conversation')) {
        try {
          const newConversation = await createConversation(token);
          conversationId = newConversation.id;
          window.location.href = `/chat?id=${conversationId}`;
          // Stop execution here - page will reload with conversation ID
          throw new Error('Redirecting to new conversation...');
        } catch (createError: any) {
          showError('Failed to create conversation: ' + createError.message);
          throw createError;
        }
      } else {
        // Some other error occurred
        showError('Failed to load conversation: ' + error.message);
        throw error;
      }
    }
  }

  // Load conversation messages
  try {
    const conversation = await getConversation(token, conversationId);
    const initialMessages = conversation.messages || [];

    // Set model selector to conversation's saved model
    if (conversation.model) {
      chatInput.setModel(conversation.model);
    }

    if (initialMessages.length > 0) {
      const formattedMessages = initialMessages.map((msg: any) => ({
        role: msg.role,
        content: msg.content,
        timestamp: new Date(msg.created_at),
        isStreaming: false
      }));
      setMessages(formattedMessages);

      // Ensure scroll to bottom after messages render
      setTimeout(() => {
        if (messagesList.children.length > 0) {
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
      }, 100);
    }
  } catch (error: any) {
    console.error('Error loading conversation:', error);
    showError('Failed to load conversation: ' + error.message);
  }

  // WebSocket configuration (conversation ID is sent in message payload, not URL)
  const WS_URL = import.meta.env.PUBLIC_WS_URL || 'ws://localhost:8000/api/ws/chat';

  // Initialize WebSocket
  const wsClient = new WebSocketClient(WS_URL, token);
  const statusQueue = new StatusQueue('statusQueueContainer');
  const connectionStatus = document.getElementById('connectionStatus') as HTMLDivElement;
  const chatForm = document.getElementById('chatForm') as HTMLFormElement;
  const chatInput = (window as any).chatInput;

  // Subscribe to message store changes
  $messages.subscribe((messages) => {
    renderMessages(messages);
  });

  // Subscribe to typing indicator
  // DISABLED: Backend status messages (like "Searching...") are more informative
  // $isTyping.subscribe((isTyping) => {
  //   if (isTyping) {
  //     statusQueue.add('typing', 'AI is typing...');
  //   } else {
  //     statusQueue.remove('typing');
  //   }
  //   scrollToBottom();
  // });

  // Render messages
  function renderMessages(messages: any[]) {
    messagesList.innerHTML = messages
      .map((msg) => {
        const isUser = msg.role === 'user';
        const timestamp = new Date(msg.timestamp).toLocaleTimeString('en-US', {
          hour: '2-digit',
          minute: '2-digit'
        });

        return `
          <div class="flex ${isUser ? 'justify-end' : 'justify-start'} mb-4 animate-fade-in">
            <div class="max-w-3xl px-3 py-2 rounded-lg shadow-sm ${
              isUser
                ? 'bg-gray-50 text-gray-900 border border-gray-200'
                : 'bg-white text-gray-900 border border-gray-200'
            }">
              <div class="break-words ${
                isUser
                  ? 'whitespace-pre-line'
                  : 'prose'
              }">
                ${isUser ? escapeHtml(msg.content) : sanitizeHtml(msg.content)}
                ${msg.isStreaming ? '<span class="inline-block w-2 h-4 bg-gray-400 animate-pulse ml-1"></span>' : ''}
              </div>
              <div class="text-xs mt-2 text-gray-500">
                ${timestamp}
              </div>
            </div>
          </div>
        `;
      })
      .join('');

    scrollToBottom();
  }

  // Escape HTML to prevent XSS in user messages
  function escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // Render markdown for assistant messages
  function sanitizeHtml(content: string): string {
    // Use renderMarkdown utility for safe markdown rendering
    return renderMarkdown(content);
  }

  // Scroll to bottom of messages (accounting for fixed input at bottom)
  function scrollToBottom() {
    setTimeout(() => {
      // Only scroll if there are messages (check after DOM update)
      if (messagesList.children.length === 0) return;

      // Scroll to absolute bottom (includes pb-44 padding)
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }, 0);
  }

  // Handle WebSocket messages
  wsClient.onMessage((data) => {
    console.log('WebSocket message:', data);

    if (data.type === 'status') {
      // Show status message in status queue (without creating a message)
      // Skip "Connected as..." messages - those are just connection confirmations
      if (data.message && !data.message.startsWith('Connected as')) {
        // Add status message to queue with 'status' id
        statusQueue.add('status', data.message);
        scrollToBottom();
      }
    } else if (data.type === 'message') {
      if (data.content) {
        // Remove status messages from queue
        statusQueue.remove('status');

        // Backend sends complete message at once (not streamed)
        // Start streaming, add content, and finalize immediately
        startStreaming();
        appendToStream(data.content);
        finalizeStreaming();
        scrollToBottom(); // Auto-scroll to show completed assistant response
        chatInput.enable(); // Re-enable input after response completes
      }
    } else if (data.type === 'video_load_confirmation') {
      // Video loading confirmation request from backend
      statusQueue.clear(); // Clear all status messages

      // Display confirmation message from assistant (using simple text)
      let confirmationText = data.message;
      if (data.video_title) {
        confirmationText += `\n\n**Video:** ${data.video_title}`;
      }
      confirmationText += '\n\nReply with "yes" or "no"';

      startStreaming();
      appendToStream(confirmationText);
      finalizeStreaming();
      chatInput.enable(); // Re-enable input to allow yes/no response
    } else if (data.type === 'video_load_status') {
      // Video loading status update
      let statusContent = '';
      if (data.status === 'started') {
        // Show status in queue instead of creating a message
        statusQueue.add('video_load', data.message || 'Loading video...');
        scrollToBottom();
        return; // Don't create a message for 'started' status
      } else if (data.status === 'completed') {
        // Remove video loading status
        statusQueue.remove('video_load');
        statusContent = `✓ **Success:** ${data.message}`;
        if (data.video_title) {
          statusContent += `\n\n**Video:** ${data.video_title}`;
        }
        chatInput.enable(); // Re-enable input after completion
      } else if (data.status === 'failed') {
        // Remove video loading status
        statusQueue.remove('video_load');
        statusContent = `✗ **Failed:** ${data.message}`;
        if (data.error) {
          statusContent += `\n\nError: ${data.error}`;
        }
        chatInput.enable(); // Re-enable input after failure
      }

      if (statusContent) {
        startStreaming();
        appendToStream(statusContent);
        finalizeStreaming();
      }
    } else if (data.type === 'error') {
      // Clear all status messages on error
      statusQueue.clear();
      showToast('Error: ' + (data.message || 'Unknown error'), 'error', 5000);
      finalizeStreaming();
      chatInput.enable();
    }
  });

  // Handle WebSocket errors
  wsClient.onError((error) => {
    console.error('WebSocket error:', error);
    connectionStatus.classList.remove('hidden');
  });

  // Connect WebSocket
  wsClient.connect();

  // Handle form submission
  chatForm.addEventListener('submit', async (e) => {
    e.preventDefault();

    const message = chatInput.getValue();
    if (!message) return;

    // Add user message to chat
    addMessage('user', message);
    scrollToBottom(); // Auto-scroll to show user's message

    // Clear input
    chatInput.clear();
    chatInput.disable();

    // Send message via WebSocket with current model selection
    const selectedModel = chatInput.getModel();
    wsClient.sendMessage(message, conversationId, selectedModel);
  });

  // Handle "New Chat" button click (from unified header)
  window.addEventListener('newChatRequest', async () => {
    try {
      const newChatBtn = document.getElementById('newChatBtn') as HTMLButtonElement | null;

      // Disable button during creation if it exists
      if (newChatBtn) {
        newChatBtn.disabled = true;
        newChatBtn.textContent = 'Creating...';
      }

      // Create new conversation
      const newConversation = await createConversation(token);

      // Redirect to new conversation
      window.location.href = `/chat?id=${newConversation.id}`;
    } catch (error: any) {
      console.error('Failed to create new conversation:', error);
      showToast('Failed to create new conversation: ' + error.message, 'error');

      // Re-enable button on error if it exists
      const newChatBtn = document.getElementById('newChatBtn') as HTMLButtonElement | null;
      if (newChatBtn) {
        newChatBtn.disabled = false;
        newChatBtn.textContent = '+ New Chat';
      }
    }
  });

  // Cleanup on page unload
  window.addEventListener('beforeunload', () => {
    wsClient.disconnect();
  });

  // Focus input on load
  chatInput.focus();
</script>

<style>
  @keyframes fade-in {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .animate-fade-in {
    animation: fade-in 0.3s ease-out;
  }
</style>
