---
/**
 * Conversation List Sidebar Component
 *
 * Displays list of conversations with create/switch/delete functionality
 * Uses conversations store for state management
 */

interface Props {
  activeId?: string | null;
}

const { activeId } = Astro.props;
---

<div class="h-full flex flex-col bg-gray-50 border-r border-gray-200">
  <!-- Sidebar Header -->
  <div class="p-4 border-b border-gray-200">
    <h2 class="text-lg font-semibold text-gray-900">Conversations</h2>
    <button
      id="newConversationBtn"
      class="mt-3 w-full px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition font-medium"
    >
      + New Conversation
    </button>
  </div>

  <!-- Conversations List -->
  <div id="conversationsList" class="flex-1 overflow-y-auto p-2">
    <!-- Populated by client-side script -->
  </div>

  <!-- Pagination Controls -->
  <div id="conversationPagination" class="hidden p-4 border-t border-gray-200">
    <div class="flex justify-between items-center text-sm">
      <button
        id="prevPageBtn"
        class="px-3 py-1 text-gray-600 hover:text-gray-900 disabled:opacity-50 disabled:cursor-not-allowed transition"
        disabled
      >
        ← Previous
      </button>
      <span id="pageInfo" class="text-gray-500"></span>
      <button
        id="nextPageBtn"
        class="px-3 py-1 text-gray-600 hover:text-gray-900 disabled:opacity-50 disabled:cursor-not-allowed transition"
        disabled
      >
        Next →
      </button>
    </div>
  </div>

  <!-- Loading State -->
  <div id="conversationsLoading" class="hidden p-4 text-center text-gray-500 text-sm">
    Loading conversations...
  </div>
</div>

<script>
  import { requireAuth, showToast, showConfirm } from '../lib/auth';
  import { getConversationsPaginated, deleteConversation, updateConversationTitle } from '../lib/api';
  import {
    $conversationList,
    $activeConversationId,
    setActiveConversation,
    setConversationsWithPagination,
    setConversationsLoading,
    setConversationsError,
    removeConversationPaginated,
    updateConversationInList,
    nextConversationPage,
    prevConversationPage
  } from '../stores/conversations';

  // Ensure user is authenticated
  const auth = await requireAuth();
  if (!auth) {
    throw new Error('Not authenticated');
  }

  const { token } = auth;

  // DOM elements
  const conversationsList = document.getElementById('conversationsList') as HTMLDivElement;
  const conversationPagination = document.getElementById('conversationPagination') as HTMLDivElement;
  const prevPageBtn = document.getElementById('prevPageBtn') as HTMLButtonElement;
  const nextPageBtn = document.getElementById('nextPageBtn') as HTMLButtonElement;
  const pageInfo = document.getElementById('pageInfo') as HTMLSpanElement;
  const conversationsLoading = document.getElementById('conversationsLoading') as HTMLDivElement;
  const newConversationBtn = document.getElementById('newConversationBtn') as HTMLButtonElement;

  // Get active conversation ID from URL
  const urlParams = new URLSearchParams(window.location.search);
  const activeId = urlParams.get('id');
  setActiveConversation(activeId);

  // Edit mode state
  let editingConversationId: string | null = null;
  let editingTitle: string = '';

  // Load conversations from backend with pagination
  async function loadConversations() {
    const state = $conversationList.get();
    setConversationsLoading(true);
    conversationsLoading.classList.remove('hidden');

    try {
      const offset = state.currentPage * state.limit;
      const data = await getConversationsPaginated(token, state.limit, offset);
      setConversationsWithPagination(data.conversations, data.total);
    } catch (error: any) {
      console.error('Failed to load conversations:', error);
      setConversationsError(error.message);
      conversationsList.innerHTML = `
        <div class="p-4 text-center text-gray-500">
          <p class="text-sm">Failed to load conversations</p>
          <button class="text-blue-600 hover:underline text-sm mt-2" onclick="location.reload()">
            Retry
          </button>
        </div>
      `;
    } finally {
      conversationsLoading.classList.add('hidden');
    }
  }

  // Escape HTML to prevent XSS attacks
  function escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // Enter edit mode for a conversation
  function startEditing(convId: string, currentTitle: string) {
    editingConversationId = convId;
    editingTitle = currentTitle;
    renderConversations();

    // Focus the input field
    setTimeout(() => {
      const input = document.querySelector(`[data-edit-input="${convId}"]`) as HTMLInputElement;
      if (input) {
        input.focus();
        input.select();
      }
    }, 10);
  }

  // Cancel edit mode
  function cancelEditing() {
    editingConversationId = null;
    editingTitle = '';
    renderConversations();
  }

  // Save edited title
  async function saveEditedTitle(convId: string, newTitle: string) {
    const trimmed = newTitle.trim();

    // Validate title (1-100 chars as per backend schema)
    if (!trimmed || trimmed.length === 0) {
      showToast('Title cannot be empty', 'error');
      return;
    }

    if (trimmed.length > 100) {
      showToast('Title must be 100 characters or less', 'error');
      return;
    }

    try {
      // Update backend
      await updateConversationTitle(token, convId, trimmed);

      // Update local state
      updateConversationInList(convId, { title: trimmed });

      // Exit edit mode
      editingConversationId = null;
      editingTitle = '';

      showToast('Title updated successfully', 'success');
    } catch (error: any) {
      showToast('Failed to update title: ' + error.message, 'error', 5000);
    }
  }

  // Render conversations list with pagination
  function renderConversations() {
    const state = $conversationList.get();
    const activeConvId = $activeConversationId.get();

    // Empty state
    if (state.conversations.length === 0 && !state.loading) {
      conversationsList.innerHTML = `
        <div class="p-4 text-center text-gray-500">
          <p class="text-sm">No conversations yet</p>
          <p class="text-xs mt-1">Click "New Conversation" to start</p>
        </div>
      `;
      conversationPagination.classList.add('hidden');
      return;
    }

    // Render conversation list
    conversationsList.innerHTML = state.conversations
      .map((conv) => {
        const isActive = conv.id === activeConvId;
        const isEditing = editingConversationId === conv.id;
        const title = escapeHtml(conv.title || 'New conversation');
        const createdDate = new Date(conv.created_at).toLocaleDateString('en-US', {
          month: 'short',
          day: 'numeric'
        });

        return `
          <div
            class="group conversation-item mb-1.5 p-2 rounded-lg transition ${
              isActive
                ? 'bg-blue-100 border border-blue-300'
                : 'bg-white border border-gray-200 hover:bg-gray-100'
            }"
            data-id="${conv.id}"
          >
            <div class="flex items-start justify-between">
              <div class="flex-1 min-w-0 pr-2 ${isEditing ? '' : 'cursor-pointer'}" ${isEditing ? '' : `data-conv-link="${conv.id}"`}>
                ${
                  isEditing
                    ? `<input
                        type="text"
                        class="w-full px-2 py-1 text-sm font-medium text-gray-900 border border-blue-400 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                        data-edit-input="${conv.id}"
                        value="${title}"
                        maxlength="100"
                      />`
                    : `<h3 class="text-sm font-medium text-gray-900 truncate" data-title-click="${conv.id}" title="Click to edit">${title}</h3>`
                }
                <p class="text-xs text-gray-500 mt-1">${createdDate}</p>
              </div>
              <button
                class="delete-btn opacity-0 group-hover:opacity-100 transition p-1 text-gray-400 hover:text-red-600"
                data-id="${conv.id}"
                data-title="${title}"
                title="Delete conversation"
              >
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                </svg>
              </button>
            </div>
          </div>
        `;
      })
      .join('');

    // Add click handlers for conversation navigation
    document.querySelectorAll('[data-conv-link]').forEach((el) => {
      el.addEventListener('click', (e) => {
        const id = (e.currentTarget as HTMLElement).getAttribute('data-conv-link');
        if (id) {
          window.location.href = `/chat?id=${id}`;
        }
      });
    });

    // Add click handlers for delete buttons
    document.querySelectorAll('.delete-btn').forEach((btn) => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation(); // Prevent navigation

        const id = (e.currentTarget as HTMLButtonElement).getAttribute('data-id');
        const title = (e.currentTarget as HTMLButtonElement).getAttribute('data-title');

        if (!id) return;

        // Confirm delete with custom modal
        const confirmed = await showConfirm(
          `Delete conversation "${title}"?\n\nThis action cannot be undone.`,
          'Delete Conversation',
          'Delete',
          'Cancel'
        );
        if (!confirmed) return;

        try {
          // Delete from backend
          await deleteConversation(token, id);

          // Remove from store
          removeConversationPaginated(id);

          // Show success toast
          showToast('Conversation deleted successfully', 'success');

          // If deleting active conversation, redirect to new conversation
          if (id === activeConvId) {
            setTimeout(() => {
              window.location.href = '/chat';
            }, 500);
          } else {
            // Reload if page is now empty and not first page
            const state = $conversationList.get();
            if (state.conversations.length === 0 && state.currentPage > 0) {
              prevConversationPage();
              await loadConversations();
            }
          }
        } catch (error: any) {
          showToast('Failed to delete conversation: ' + error.message, 'error', 5000);
        }
      });
    });

    // Add click handlers for title editing
    document.querySelectorAll('[data-title-click]').forEach((el) => {
      el.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent navigation
        const id = (e.currentTarget as HTMLElement).getAttribute('data-title-click');
        if (id) {
          const conv = state.conversations.find(c => c.id === id);
          if (conv) {
            startEditing(id, conv.title);
          }
        }
      });
    });

    // Add handlers for edit inputs (Enter to save, Escape to cancel, blur to save)
    document.querySelectorAll('[data-edit-input]').forEach((input) => {
      const inputEl = input as HTMLInputElement;
      const id = inputEl.getAttribute('data-edit-input');
      if (!id) return;

      // Handle keyboard events
      inputEl.addEventListener('keydown', async (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          await saveEditedTitle(id, inputEl.value);
        } else if (e.key === 'Escape') {
          e.preventDefault();
          cancelEditing();
        }
      });

      // Handle blur (save on focus loss)
      inputEl.addEventListener('blur', async () => {
        // Small delay to allow click events to fire first
        setTimeout(async () => {
          if (editingConversationId === id) {
            await saveEditedTitle(id, inputEl.value);
          }
        }, 100);
      });
    });

    // Update pagination controls
    const totalPages = Math.ceil(state.total / state.limit);
    if (totalPages > 1) {
      conversationPagination.classList.remove('hidden');
      pageInfo.textContent = `Page ${state.currentPage + 1} of ${totalPages}`;
      prevPageBtn.disabled = state.currentPage === 0;
      nextPageBtn.disabled = state.currentPage >= totalPages - 1;
    } else {
      conversationPagination.classList.add('hidden');
    }
  }

  // Pagination button handlers
  prevPageBtn.addEventListener('click', async () => {
    prevConversationPage();
    await loadConversations();
  });

  nextPageBtn.addEventListener('click', async () => {
    nextConversationPage();
    await loadConversations();
  });

  // Subscribe to conversation list store changes
  $conversationList.subscribe(() => {
    renderConversations();
  });

  // New conversation button
  newConversationBtn.addEventListener('click', () => {
    window.location.href = '/chat';
  });

  // Load conversations on mount
  loadConversations();
</script>
